from collections import deque
from sys import stdin
input = stdin.readline

while True :
    case = list(map(int,input().split()))
    if case[0] == 0 : break

    n = case[0]
    rtgs = case[1:]

    stk = deque()
    maxArea = 0

    for idx, rtg in enumerate(rtgs) :
        while stk and stk[-1][1] > rtg :
            tempIdx, tempRtg = stk.pop()
            maxArea = max(maxArea, tempRtg * (idx-1-stk[-1][0] if stk else idx)) # 생각!
        stk.append((idx,rtg))
    
    while stk :
        tempIdx, tempRtg = stk.pop()
        maxArea = max(maxArea, tempRtg * (n-stk[-1][0]-1 if stk else n))
        
    print(maxArea)
        
        



'''
🤔🤔🤔 문제정의를 잘 하자 🤔🤔🤔

입력 : 테스트 케이스들이 여러개의 줄로 직사각형 수 n 및 직사각형의 높이들로 주어짐.
출력 : 직사각형의 최대 넓이

찾아야하는 값 : 
알고리즘 : 스택

-----
하나하나 확인하면서 매번 max 값 비교해서 갱신, 사이즈가 작아지면 이전꺼는 지우기?(작아져도 이전거랑 이어져서 클수도 있음...) 사이즈가 커지면 누적하되 이전거의 누적 넓이보다 하나의 넓이가 더 크면 이전꺼 지우기
근데 1이나 2나 등등이 n개 늘어져있는게 더 클수도 있어보임,,그래서 0이 아닌 동안은, 최소값과 아닌 갯수 세서 비교해줄 필요도 있지 않을까..?

될 수  있는 케이스 정리
- 최소값이 n개 연결되어서 최대가 되는 경우
- 제일 긴 하나가 최대가 되는 경우
- 연속된것중에 왼쪽 끝에 있는 막대의 길이 * x or 오른쪽 끝에 있는 막대의 길이 * x


어려부...............
답봄.. ㅠ
https://hooongs.tistory.com/330

- 경우의 수가 너무 많음.
- 하지만 모든 경우의 수를 따로 나눠서 할 수는 없음. 단순화할 필요.
- 막대기는 크기가 줄어드는 경우와 늘어나는 두가지 경우로 나눌 수 있음. 
- 기본적으로 '늘어나면 계속 스택에 넣는다' 와 ('줄어들면 스택에서 이전꺼 다 버린다'가 틀림. 기준을 스택 맨 위에꺼로 잡아야함!!! 스택에 대한 이해 ㅠ) 로 규칙을 정해야함. 그 안에서 경우의 수들을 어떻게 계산할 것인가
- 막대기가 커지는 경우에는 가장 작은것으로부터 이어서 크게 만들 수 있음 - 단계적으로 커지는 경우?? 엄청나게 큰 것이 섞여있는 경우?? 스택에서 빼면서 하나하나 계산해줄 필요성. 
    => 한번에 다하려고 하니까 안됨. 쪼개야함. 한번에 다 쪼개는게 아니라, 맨 위에꺼보다 작은게 나올때에만 쪼갬. 즉, 맨위에꺼가 새로나온거보다 작으면 다시 그대로 냅둠. 나중에 계산할것.
- 막대기가 작아지는 경우 - 작아진 막대 기준으로도 쌓여있는 스택만큼 계산시 큰 넓이가 나올 수 있음. => 맨 마지막꺼 기준으로 작아졌지만, 그 왼쪽에 작아진것 기준으론 커진거로 봐야함. 그러면 스택에 남겨놓고 나중에 계산 가능함.
- 값 뿐만 아니라 인덱스를 저장할 필요가 있음!
-----


'''