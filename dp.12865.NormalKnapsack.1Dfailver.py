from sys import stdin
input = stdin.readline

N, K = map(int,input().split())
dp = [0] * (10**5)
for _ in range(N) :
    w, v = map(int,input().split())
    dp[w] = max(dp[w],v)

for i in range(2, K+1) :
    for j in range(1, i//2 if i%2==0 else i//2+1) :
        dp[i] = max(dp[i], dp[j] + dp[i-j])
        
# print(*dp)
print(max(dp))


## 1차원으론 웨않뒘...?? ㅠ
'''
문제의 조건에서 동일한 무게는 유일하다는 조건이 없음
즉, 9키로일떄 3키로짜리 물건이 3개있는데 그 세가지 모두 가치가 높다면 그 세가지로 채우는게 답이 될것
따라서 이문제는 무게에 따른 수열로 1차원으로 접근하면 풀 수 없음.

이러한 유형을 접근할 때에는 변수가 무엇인지 파악하는것이 중요할 듯 함.
완전탐색을 하더라도, 결국은 아이템을 넣냐 마냐를 따지면서 파악할 것. 따라서 담는 아이템 갯수에 대한 파악이 필요함.
그런데 아이템을 담고 안담고만 따지기엔 무게가 이쪽저쪽임. 그래서 작은 무게부터 담아보는게 필요함.
그러면 계속 뺏다 넣었다 하는 과정이 '중복'되게 됨.
즉, 부분적인 반복이 계속 일어난다는 것. 따라서, 무게1~K, 아이템갯수 1~N 까지 진행하면서 메모해주는 방법, 즉 dp가 사용되는 것..!

'''